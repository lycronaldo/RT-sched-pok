# POK 测试报告

## 1. 调度算法应用结果

### 1.1 抢占式优先级调度

* 时钟中断为1ms触发一次 timer interrupt（1 个 tick），`POK_TIMER_QUANTUM`（20）次 timer interrupt 后触发 `pok_sched`
* 一共使用一个分区，此分区包含3个可调度用户线程。（除开idle、kernel和main线程）

**线程参数**

|                                | time_capacity     | period | priority |
| :----------------------------- | ----------------- | ------ | -------- |
| **网络收发包线程（Thread 1）** | 1 （20个tick）    | 100    | 0        |
| **飞行控制线程（Thread 2）**   | 25 （500个tick）  | 1000   | 1        |
| **视频数据传输（Thread 3）**   | 50 （1000个tick） | 1000   | 2        |

**应用结果**

 <img src="POK 测试报告.assets/Screen Shot 2020-12-12 at 7.42.44 PM.png" alt="image-20201212201544778" style="zoom:50%;" />

**结果分析**

可以看到在第660个 tick 之前每隔100个 tick （T1的周期）都会运行一次T1，共运行20个 tick。剩余时间都是 T2 在运行。而到第660个 tick 的时候，T2第一次执行完成，优先级最低的T3终于得到cpu开始执行。



### 1.2 抢占式EDF调度

**应用环境**

* 时钟中断为1ms触发一次，每次时钟中断均会触发调度。

* 一共使用一个分区，此分区包含3个可调度用户线程。（除开idle、kernel和main线程）
* 使用线程的time_capacity属性作为其需要运行的时间，time_capacity耗尽即代表其完成任务。
* 若一个进程错过了其deadline，就kill之。
* 由于篇幅限制，只让其运行40个tick。

**线程参数**

|               | 线程1 | 线程2 | 线程3 |
| ------------- | ----- | ----- | ----- |
| Period        | 15    | 20    | 30    |
| Deadline      | 10    | 15    | 25    |
| Time_capacity | 5     | 8     | 10    |
| Priority      | 42    | 42    | 42    |

**应用结果**

 <img src="POK 测试报告.assets/image-20201212201544778.png" alt="image-20201212201544778" style="zoom:50%;" />



## 2. 不同调度算法应用简单比较

**抢占式优先级调度**

本次作业中实现的是一种静态的优先级调度，即任务创建时给定的优先级之后不会再进行调整。优先级调度的优点和缺点都很明显。优点是它能够保证优先级更高的任务得到优先执行，尤其是在混合关键性系统当中，不同的任务具有不同的关键性（关键性指 deadline miss 造成后果的严重性）。但是即使在整个系统的利用率不到100%时，使用抢占式的优先级调度依然有可能造成某些任务出现 deadline miss 的情况。还有非常重要的一点，就是任务的优先级把关键性和时间敏感性杂糅在了一起。比如上述网络收发包线程和飞行控制线程的例子，飞行控制线程更有更高的关键性，但是我们应该给网络收发包线程更高的优先级让其能够抢占cpu，同时还要保证不会影响飞行控制线程能够顺利完成执行，这一点还需要引入其他机制来保证。

**抢占式EDF调度**

抢占式的EDF调度算法的可调度行已经经过了严格的证明，它能够保证在系统利用率不超过100%时让每个任务都能在 deadline 之前完成。但是当系统的利用率超过100%时，发生 deadline miss 的线程并不是一个所有线程的固定的子集，尤其是在每个线程到达时间和执行时间都在动态变化的情况下。这个随机性也就导致了 EDF 在工业界并不是十分流行。