# POK 测试报告

## 1. 调度算法应用结果

### 1.1 抢占式优先级调度

* 时钟中断为1ms触发一次 timer interrupt（1 个 tick），`POK_TIMER_QUANTUM`（20）次 timer interrupt 后触发 `pok_sched`
* 一共使用一个分区，此分区包含3个可调度用户线程。（除开idle、kernel和main线程）

**线程参数**

|                                | time_capacity     | period | priority |
| :----------------------------- | ----------------- | ------ | -------- |
| **网络收发包线程（Thread 1）** | 1 （20个tick）    | 100    | 0        |
| **飞行控制线程（Thread 2）**   | 25 （500个tick）  | 1000   | 1        |
| **视频数据传输（Thread 3）**   | 50 （1000个tick） | 1000   | 2        |

**应用结果**

 <img src="POK 测试报告.assets/Screen Shot 2020-12-12 at 7.42.44 PM.png" alt="image-20201212201544778" style="zoom:50%;" />

**结果分析**

可以看到在第660个 tick 之前每隔100个 tick （T1的周期）都会运行一次T1，共运行20个 tick。剩余时间都是 T2 在运行。而到第660个 tick 的时候，T2第一次执行完成，优先级最低的T3终于得到cpu开始执行。



### 1.2 抢占式EDF调度

**应用环境**

* 时钟中断为1ms触发一次，每次时钟中断均会触发调度。

* 一共使用一个分区，此分区包含3个可调度用户线程。（除开idle、kernel和main线程）
* 使用线程的time_capacity属性作为其需要运行的时间，time_capacity耗尽即代表其完成任务。
* 若一个进程错过了其deadline，就kill之。
* 只让其运行40个tick。

**线程参数**

|               | 线程1 | 线程2 | 线程3 |
| ------------- | ----- | ----- | ----- |
| Period        | 15    | 20    | 30    |
| Deadline      | 10    | 15    | 25    |
| Time_capacity | 5     | 8     | 10    |
| Priority      | 42    | 42    | 42    |

**应用结果**

 <img src="POK 测试报告.assets/image-20201212201544778.png" alt="image-20201212201544778" style="zoom:50%;" />



### 1.3 MLFQ 调度算法测试

**应用环境**

* 时钟中断为1ms触发一次，每次时钟中断均会触发调度。
* 一共使用一个分区，此分区包含3个可调度用户线程。（除开idle、kernel和main线程）
* 使用线程的time_capacity属性作为其需要运行的时间，time_capacity耗尽即代表其完成任务。
* 每个线程都有当前的 time_slice，time_slice 耗尽将会进入下一级队列。
* 由于篇幅限制，只让其运行30个tick。
* 一共三级队列，每个队列内部为 round robin， 时间片分别为2,4,6。

**线程参数**

* 同 1.2 

**运行结果**

 <img src="POK 测试报告.assets/DeepinScreenshot_select-area_20201213184403.png" alt="image-20201212201544778" style="zoom:50%;" />

**结果分析**

* 可以看到，第一次进入调度（tick 3）时，先把3个线程全部入队到队列0（第一级队列），然后选择线程1进行执行。

* tick 5：线程1的时间片耗尽，线程1进入队列1, 选择队列0的队头线程2进行运行。
* tick7：线程2的时间片耗尽，线程2进入队列1, 选择队列0的队头线程3进行运行。
* tick9：线程3的时间片耗尽，线程3进入队列1,此时选择队列1的队头线程1进行运行。
* tick12：线程1执行完成，出队。选择队列1的队头线程2进行运行。
* tick15：线程1被 activate，重新进入队列0。
* tick16：线程2时间片耗尽，进入队列2,此时会选择队列0的队头线程0进行运行。
* 后面每次调度是也会按照此规律继续进行调度。可以看到每个线程被创建或者被激活时都会进入队列0,。只有一个线程 time_capacity耗尽或者 time_slice 耗尽时才会重新选择线程。重新选择线程时会按照队列的优先级进行查找，找到优先级最高的非空队列的队头进行运行。

### 1.4 带权重的round-robin调度

* 时钟中断为1ms触发一次 timer interrupt（1 个 tick），`POK_TIMER_QUANTUM`（20）次 timer interrupt 后触发 `pok_sched`
* 一共使用一个分区，此分区包含3个可调度用户线程。（除开idle、kernel和main线程）

**线程参数**

|                                | time_capacity     | period | weight |
| :----------------------------- | ----------------- | ------ | -------- |
| **鼠标移动线程（Thread 1）**   | 10 （200个tick）      | 100 |   4   |
| **界面渲染线程（Thread 2）**   | 10 （200个tick）      | 100 |   3   |
| **数据更新线程（Thread 3）**      | 10 （200个tick）      | 100 |   2   |

**应用结果**

 <img src="POK 测试报告.assets/Screen Shot 2020-12-12 at 7.42.44 PM.png" alt="image-20201212201544778" style="zoom:50%;" />

**结果分析**

可以看到，第一个线程执行的次数最多，也就是充分保证了能够完成操作。但是在第一个线程完全执行完毕之前，第二和第三个线程也得到了一定时间的执行。
可以实现较优的用户体验。

## 2. 不同调度算法应用简单比较

**抢占式优先级调度**

本次作业中实现的是一种静态的优先级调度，即任务创建时给定的优先级之后不会再进行调整。优先级调度的优点和缺点都很明显。优点是它能够保证优先级更高的任务得到优先执行，尤其是在混合关键性系统当中，不同的任务具有不同的关键性（关键性指 deadline miss 造成后果的严重性）。但是即使在整个系统的利用率不到100%时，使用抢占式的优先级调度依然有可能造成某些任务出现 deadline miss 的情况。还有非常重要的一点，就是任务的优先级把关键性和时间敏感性杂糅在了一起。比如上述网络收发包线程和飞行控制线程的例子，飞行控制线程更有更高的关键性，但是我们应该给网络收发包线程更高的优先级让其能够抢占cpu，同时还要保证不会影响飞行控制线程能够顺利完成执行，这一点还需要引入其他机制来保证。

**抢占式EDF调度**

抢占式的EDF调度算法的可调度行已经经过了严格的证明，它能够保证在系统利用率不超过100%时让每个任务都能在 deadline 之前完成。但是当系统的利用率超过100%时，发生 deadline miss 的线程并不是一个所有线程的固定的子集，尤其是在每个线程到达时间和执行时间都在动态变化的情况下。这个随机性也就导致了 EDF 在工业界并不是十分流行。

**带权重的round-robin调度**

带权重的round-robin面对的场景是比较具有特殊性的。首先，该场景需要满足的条件是适用round-robin算法，即每个任务的重要性相差不多。其次，权重的配置应该根据重要性的细微差异来进行分配。
因为deadline miss在软实时系统中主要体现在用户体验的下降上，所以必须对特定线程的deadline miss的结果进行缜密分析才能科学的配置权重。在当前案例中，显然鼠标的可操纵性重要性相对最高，
至少在图形界面为空白的情况下必须先保证鼠标线程的执行。由于对于数据的获取会涉及到网络I/O或是磁盘I/O的操作，因此重要性显然最低（可以忍受图形界面渲染完毕但是链接仍不可用的情况）。故需要
给数据更新线程配置最低的权重。由于应用范围较窄，所以weighted-round-robin算法并没有得到广泛的应用，一般针对特定的应用场景进行专门的实现。